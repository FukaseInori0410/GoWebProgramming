# Chapter3 接收请求
## 多路复用器对URL的绑定
### 最小惊讶原则
在进行程序设计的时候，应该做那些合乎常理的事情，使事务的行为总是显而易见、始终如一并且合乎情理。  
例如：在程序为"/""/hello""/world"这些URL绑定了处理器的情况下，如果发送以"/random"或"/hello/there"结尾的URL请求，将会使用绑定"/"的处理器进行处理。若程序为"/hello/"的URL请求绑定了处理器，则上述情况会绑定到该处理器上处理。
# Chapter2 处理请求
## 使用Cookie实现闪现消息
### 使用场景
用户由于某种原因发送帖子失败了，论坛要向用户展示一条帖子发布失败的消息，但正常访问该页面不该看到这个消息，因此刷新之后就看不到了，这种消息称为闪现消息。  
### 原理
为用户创建同名cookie，将MaxAge参数设置为负数，Expires值设置成过去的时间，比如time.Unix(1,0)，发送给客户端，相当于完全移除了这个cookie。
# Chapter6 存储数据
## 关于Mysql自增列
[Mysql设置主键自增，删除数据后，主键id依然从删除位置增加 ](https://blog.csdn.net/weixin_45682496/article/details/115862243)  
要使删除后自增列起始数值变化，需使用如下语句：
```
alter table 表名 AUTO_INCREMENT=预期起始值;
```
## DELETE和TRUNCATE区别
|/|TRUNCATE|DELETE|
|:-:|:-:|:-:|
|**条件删除**|不支持|支持|
|**事务回滚**|不支持|支持|
|**清理速度**|快|慢|
|**高水位重置**|是|否|
# Chapter7 Go Web 服务
基于postgres关系数据库，包含posts和comments两个关联数据表的论坛web服务，实现了增删改查功能。
# Chapter8 应用测试
## 单元测试门类
1. 功能测试：测试模块功能是否正常
2. 基准测试（benchmarking）：测试模块运行效率（速度）
## 独立的单元测试
被测试代码独立性不足以进行替身测试时，需要使用依赖注入方法对模块进行解耦合。如本书第七章的Web服务中，server.go中的每个函数都严重依赖于data.go中的全局变量sql.Db。
### 1. 依赖注入
将一个包含sql.Db的Post结构传递到函数调用流程中，以此来对简单的Web服务实现依赖注入模式。由于Post结构中包含了sql.Db，server.go中所有函数都不再依赖data.go中的全局变量sql.Db。Post结构使用接口进行定义。
### 2. 测试替身
定义FakePost代替Post传入handleRequest中让测试模块不用去操作数据库，有利于对每个部分的独立测试。
# Chapter9 发挥Go的并发优势
## 马赛克图片生成Web应用
### 马赛克图片生成算法
1. 通过扫描图片目录，并使用图片的文件名作为键，图片的平均颜色作为值，构建出一个由瓷砖图片自称的散列，也就是一个瓷砖图片数据库。通过计算图片中每个像素红绿蓝三种颜色的综合，并将他们除以像素的总数量，我们就得到了一个三元组，这个三元组就是图片的平均颜色。
2. 根据瓷砖图片的大小，将目标图片切割成一系列尺寸更小的子图片。
3. 对于目标图片切割出的每张子图片，将他们位于左上方的第一个像素设定为该图片的平均颜色。
4. 根据子图片的平均颜色，在瓷砖图片数据库中找出一张平均颜色与之最接近的瓷砖图片，然后在目标图片的相应位置上使用瓷砖图片去代替原有的子图片。为了找出最接近的平均颜色，程序需要将子图片的平均颜色以及瓷砖图片的平均颜色都转换成三维空间中的一个点，并计算二者欧氏距离。
5. 当一张瓷砖图片被选中之后，程序就会把这张图片从瓷砖图片数据库中移除，以此来保证马赛克图片中的每张瓷砖图片都是独一无二，各不相同的。
### 并发思路
将原图切割成四块，使用四条go程分别进行马赛克处理。处理过程中存在以下注意点：  
* **互斥**：马赛克图片中的每一块瓷砖图片都要是独一无二的，所以对瓷砖图片的选取和删除应当在互斥区内进行。需要将neares函数设定为DB结构的一个方法，在选取（计算距离）和删除操作时使用*syn.mutex对资源上锁。
* **阻塞**：在cut函数和combine函数间使用通道传递图片，使combine函数在收到全部四块小块图片之前处于阻塞状态。
### 踩坑
1. 指针初始化  
go语言中变量若不进行初始化会指向该类型的0值，对于指针来说是nil。在这种状况下不能直接调用指针，不然会报错。需要进行初始化，分配内存空间后再进行调用。  
```
tiles := DB{
		store: db,
		mutex: &sync.Mutex{},
	}
```
2. 多路复用器对URL的绑定，见Chapter3.
# 新特性
1. Go1.16废弃io/ioutil包，原因一方面是util后缀的命名方法表意不明，另外十分热门的ioutil.ReadAll函数存在以下两个缺点（读取大文件时频繁的切片扩容）：  
    1. 性能问题，文件越大，性能越差。
    2. 文件过大的话，可能直接撑爆内存，导致程序崩溃。  
